unit Plus.ProxyGenerator;

interface

uses
  Data.DB,
  System.Classes,
  System.Generics.Collections,
  System.SysUtils;

type
  EProxyGenError = class(Exception);

  TProxyGenerator = class(TComponent)
  private
    Fields: TList<TField>;
    FDataSet: TDataSet;
    FCode: String;
    procedure FillFieldsFromDataSet(ds: TDataSet);
    procedure SetDataSet(const aDataSet: TDataSet);
    procedure SetCode(const aCode: String);
  protected
    procedure DoGenerateProxy(ds: TDataSet; const code: TStrings);
  public
    constructor Create(Owner: TComponent); override;
    destructor Destroy; override;
    property code: String read FCode write SetCode;
    property DataSet: TDataSet read FDataSet write SetDataSet;
    procedure Generate;
  end;

implementation

uses App.AppInfo;

resourcestring
  ErrDataSetIsRequired = 'DataSet is required to generate new proxy';
  ErrDataSetNotActive = 'DataSet have to be active!';

type
  TFieldHelper = class helper for TField
    function ToClass: TClass;
  end;

  { TFieldHelper }

function TFieldHelper.ToClass: TClass;
begin
  Result := Data.DB.DefaultFieldClasses[Self.DataType];
end;

{ TProxyGenerator }

constructor TProxyGenerator.Create(Owner: TComponent);
begin
  inherited;
  Fields := TList<TField>.Create();
end;

destructor TProxyGenerator.Destroy;
begin
  Fields.Free;
  inherited;
end;

procedure TProxyGenerator.FillFieldsFromDataSet(ds: TDataSet);
var
  i: Integer;
begin
  Fields.Clear;
  for i := 0 to ds.Fields.Count - 1 do
    Fields.Add(ds.Fields[i]);
end;

procedure TProxyGenerator.DoGenerateProxy(ds: TDataSet; const code: TStrings);
var
  fld: TField;
begin
  FillFieldsFromDataSet(ds);
  code.Add('// Generated by ' + TAppInfo.AppName + ' at ' +
    FormatDateTime('yyyy-mm-dd hh:nn', Now));
  code.Add('uses');
  code.Add('  Data.DB,');
  code.Add('  Data.DataProxy;');
  code.Add('');
  code.Add('type');
  code.Add('  T{ObjectName}Proxy = class(TDatasetProxy)');
  code.Add('  private');
  for fld in Fields do
    code.Add('    F' + fld.FieldName + ' :' + fld.ToClass.ClassName + ';');
  code.Add('  protected');
  code.Add('    procedure ConnectFields; override;');
  code.Add('  public');
  for fld in Fields do
    code.Add('    property ' + fld.FieldName + ' :' + fld.ToClass.ClassName +
      ' read F' + fld.FieldName + ';');
  code.Add('    // this property should be hidden, but during migration can be usefull');
  code.Add('    // property DataSet: TDataSet read FDataSet;');
  code.Add('  end;');
  code.Add('');
  code.Add('implementation');
  code.Add('');
  code.Add('uses');
  code.Add('  System.SysUtils,');
  code.Add('  Database.Connector;');
  code.Add('');
  code.Add('procedure T{ObjectName}Proxy.ConnectFields;');
  code.Add('begin');
  for fld in Fields do
    code.Add('  ' + fld.FieldName + ' := FDataSet.FieldByName(' +
      QuotedStr(fld.FieldName) + ') as ' + fld.ToClass.ClassName + ';');
  code.Add('end;');
end;

procedure TProxyGenerator.Generate;
var
  CodeList: TStringList;
begin
  if DataSet = nil then
    raise EProxyGenError.Create(ErrDataSetIsRequired);
  if not DataSet.Active then
    raise EProxyGenError.Create(ErrDataSetNotActive);
  CodeList := TStringList.Create;
  try
    DoGenerateProxy(DataSet, CodeList);
    code := CodeList.Text;
  finally
    CodeList.Free;
  end;
end;

procedure TProxyGenerator.SetCode(const aCode: String);
begin
  FCode := aCode;
end;

procedure TProxyGenerator.SetDataSet(const aDataSet: TDataSet);
begin
  FDataSet := aDataSet;
end;

end.
